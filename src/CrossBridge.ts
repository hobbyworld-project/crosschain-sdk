/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace ITokenFactory {
  export type TokenAttestationStruct = {
    tokenAddress: string;
    tokenChain: BigNumberish;
    tokenType: BigNumberish;
    decimals: BigNumberish;
    symbol: string;
    name: string;
    wrappedTokenAddress: string;
  };

  export type TokenAttestationStructOutput = [
    string,
    BigNumber,
    number,
    number,
    string,
    string,
    string
  ] & {
    tokenAddress: string;
    tokenChain: BigNumber;
    tokenType: number;
    decimals: number;
    symbol: string;
    name: string;
    wrappedTokenAddress: string;
  };

  export type TokenInfoStruct = { token: string; isWrapped: boolean };

  export type TokenInfoStructOutput = [string, boolean] & {
    token: string;
    isWrapped: boolean;
  };
}

export declare namespace ICrossBridge {
  export type TokenTransferBaseStruct = {
    timestamp: BigNumberish;
    srcChain: BigNumberish;
    srcAddress: string;
    dstChain: BigNumberish;
    dstAddress: string;
    tokenAddress: string;
  };

  export type TokenTransferBaseStructOutput = [
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    string,
    string
  ] & {
    timestamp: BigNumber;
    srcChain: BigNumber;
    srcAddress: string;
    dstChain: BigNumber;
    dstAddress: string;
    tokenAddress: string;
  };
}

export interface CrossBridgeInterface extends utils.Interface {
  functions: {
    "addDeployedToken(address)": FunctionFragment;
    "attestToken((address,uint256,uint8,uint8,string,string,address))": FunctionFragment;
    "attestedTokens(bytes32)": FunctionFragment;
    "bridgeTokens(address,uint256,uint256,address)": FunctionFragment;
    "bridgeTokensBack(uint256,address,bytes32,bool)": FunctionFragment;
    "changeRelayer(address)": FunctionFragment;
    "getDeployedToken(address)": FunctionFragment;
    "getSupportedTokens()": FunctionFragment;
    "getWrappedToken(address,uint256)": FunctionFragment;
    "isWrappedTokenSupported(address,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "relayer()": FunctionFragment;
    "releaseTokens(uint256,address,address,bool)": FunctionFragment;
    "releaseWrappedTokens(uint256,address,bytes32)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "tokenFactory()": FunctionFragment;
    "tokenTransfers(bytes32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "wrappedAttestedTokens(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addDeployedToken"
      | "attestToken"
      | "attestedTokens"
      | "bridgeTokens"
      | "bridgeTokensBack"
      | "changeRelayer"
      | "getDeployedToken"
      | "getSupportedTokens"
      | "getWrappedToken"
      | "isWrappedTokenSupported"
      | "owner"
      | "relayer"
      | "releaseTokens"
      | "releaseWrappedTokens"
      | "renounceOwnership"
      | "tokenFactory"
      | "tokenTransfers"
      | "transferOwnership"
      | "wrappedAttestedTokens"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addDeployedToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "attestToken",
    values: [ITokenFactory.TokenAttestationStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "attestedTokens",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeTokens",
    values: [string, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeTokensBack",
    values: [BigNumberish, string, BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "changeRelayer",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getDeployedToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getSupportedTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getWrappedToken",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isWrappedTokenSupported",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "relayer", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "releaseTokens",
    values: [BigNumberish, string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "releaseWrappedTokens",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenTransfers",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "wrappedAttestedTokens",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "addDeployedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeTokensBack",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeRelayer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDeployedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSupportedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWrappedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isWrappedTokenSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "relayer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "releaseTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseWrappedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenTransfers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wrappedAttestedTokens",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
    "TokensBridged(bytes32,uint8)": EventFragment;
    "TokensBridgedBack(uint256,address,bytes32,bool)": EventFragment;
    "TokensReleased(uint256,address,address,bool)": EventFragment;
    "WrappedTokensReleased(uint256,address,bytes32)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensBridged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensBridgedBack"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensReleased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WrappedTokensReleased"): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface TokensBridgedEventObject {
  transferID: string;
  tokenType: number;
}
export type TokensBridgedEvent = TypedEvent<
  [string, number],
  TokensBridgedEventObject
>;

export type TokensBridgedEventFilter = TypedEventFilter<TokensBridgedEvent>;

export interface TokensBridgedBackEventObject {
  amount: BigNumber;
  to: string;
  attestationID: string;
  convertToNative: boolean;
}
export type TokensBridgedBackEvent = TypedEvent<
  [BigNumber, string, string, boolean],
  TokensBridgedBackEventObject
>;

export type TokensBridgedBackEventFilter =
  TypedEventFilter<TokensBridgedBackEvent>;

export interface TokensReleasedEventObject {
  amount: BigNumber;
  to: string;
  token: string;
  convertToNative: boolean;
}
export type TokensReleasedEvent = TypedEvent<
  [BigNumber, string, string, boolean],
  TokensReleasedEventObject
>;

export type TokensReleasedEventFilter = TypedEventFilter<TokensReleasedEvent>;

export interface WrappedTokensReleasedEventObject {
  amount: BigNumber;
  to: string;
  attestationID: string;
}
export type WrappedTokensReleasedEvent = TypedEvent<
  [BigNumber, string, string],
  WrappedTokensReleasedEventObject
>;

export type WrappedTokensReleasedEventFilter =
  TypedEventFilter<WrappedTokensReleasedEvent>;

export interface CrossBridge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CrossBridgeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addDeployedToken(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    attestToken(
      _attestation: ITokenFactory.TokenAttestationStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    attestedTokens(
      attestationID: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, number, number, string, string, string] & {
        tokenAddress: string;
        tokenChain: BigNumber;
        tokenType: number;
        decimals: number;
        symbol: string;
        name: string;
        wrappedTokenAddress: string;
      }
    >;

    bridgeTokens(
      _token: string,
      _amount: BigNumberish,
      _dstChain: BigNumberish,
      _dstAddress: string,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    bridgeTokensBack(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      _convertToNative: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    changeRelayer(
      _relayer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getDeployedToken(
      _wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { deployedToken: string; chainId: BigNumber }
    >;

    getSupportedTokens(
      overrides?: CallOverrides
    ): Promise<[ITokenFactory.TokenInfoStructOutput[]]>;

    getWrappedToken(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { wrappedToken: string }>;

    isWrappedTokenSupported(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    relayer(overrides?: CallOverrides): Promise<[string]>;

    releaseTokens(
      _amount: BigNumberish,
      _to: string,
      _token: string,
      _convertToNative: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    releaseWrappedTokens(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    tokenFactory(overrides?: CallOverrides): Promise<[string]>;

    tokenTransfers(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [ICrossBridge.TokenTransferBaseStructOutput, BigNumber] & {
        tokenTransfer: ICrossBridge.TokenTransferBaseStructOutput;
        amount: BigNumber;
      }
    >;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    wrappedAttestedTokens(
      wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, number, number, string, string, string] & {
        tokenAddress: string;
        tokenChain: BigNumber;
        tokenType: number;
        decimals: number;
        symbol: string;
        name: string;
        wrappedTokenAddress: string;
      }
    >;
  };

  addDeployedToken(
    _tokenAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  attestToken(
    _attestation: ITokenFactory.TokenAttestationStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  attestedTokens(
    attestationID: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, number, number, string, string, string] & {
      tokenAddress: string;
      tokenChain: BigNumber;
      tokenType: number;
      decimals: number;
      symbol: string;
      name: string;
      wrappedTokenAddress: string;
    }
  >;

  bridgeTokens(
    _token: string,
    _amount: BigNumberish,
    _dstChain: BigNumberish,
    _dstAddress: string,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  bridgeTokensBack(
    _amount: BigNumberish,
    _to: string,
    _attestationID: BytesLike,
    _convertToNative: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  changeRelayer(
    _relayer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getDeployedToken(
    _wrappedToken: string,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber] & { deployedToken: string; chainId: BigNumber }
  >;

  getSupportedTokens(
    overrides?: CallOverrides
  ): Promise<ITokenFactory.TokenInfoStructOutput[]>;

  getWrappedToken(
    _tokenAddress: string,
    _tokenChain: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  isWrappedTokenSupported(
    _tokenAddress: string,
    _tokenChain: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  relayer(overrides?: CallOverrides): Promise<string>;

  releaseTokens(
    _amount: BigNumberish,
    _to: string,
    _token: string,
    _convertToNative: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  releaseWrappedTokens(
    _amount: BigNumberish,
    _to: string,
    _attestationID: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  tokenFactory(overrides?: CallOverrides): Promise<string>;

  tokenTransfers(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [ICrossBridge.TokenTransferBaseStructOutput, BigNumber] & {
      tokenTransfer: ICrossBridge.TokenTransferBaseStructOutput;
      amount: BigNumber;
    }
  >;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  wrappedAttestedTokens(
    wrappedToken: string,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, number, number, string, string, string] & {
      tokenAddress: string;
      tokenChain: BigNumber;
      tokenType: number;
      decimals: number;
      symbol: string;
      name: string;
      wrappedTokenAddress: string;
    }
  >;

  callStatic: {
    addDeployedToken(
      _tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    attestToken(
      _attestation: ITokenFactory.TokenAttestationStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    attestedTokens(
      attestationID: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, number, number, string, string, string] & {
        tokenAddress: string;
        tokenChain: BigNumber;
        tokenType: number;
        decimals: number;
        symbol: string;
        name: string;
        wrappedTokenAddress: string;
      }
    >;

    bridgeTokens(
      _token: string,
      _amount: BigNumberish,
      _dstChain: BigNumberish,
      _dstAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    bridgeTokensBack(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      _convertToNative: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    changeRelayer(_relayer: string, overrides?: CallOverrides): Promise<void>;

    getDeployedToken(
      _wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { deployedToken: string; chainId: BigNumber }
    >;

    getSupportedTokens(
      overrides?: CallOverrides
    ): Promise<ITokenFactory.TokenInfoStructOutput[]>;

    getWrappedToken(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    isWrappedTokenSupported(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    relayer(overrides?: CallOverrides): Promise<string>;

    releaseTokens(
      _amount: BigNumberish,
      _to: string,
      _token: string,
      _convertToNative: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    releaseWrappedTokens(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    tokenFactory(overrides?: CallOverrides): Promise<string>;

    tokenTransfers(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [ICrossBridge.TokenTransferBaseStructOutput, BigNumber] & {
        tokenTransfer: ICrossBridge.TokenTransferBaseStructOutput;
        amount: BigNumber;
      }
    >;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    wrappedAttestedTokens(
      wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, number, number, string, string, string] & {
        tokenAddress: string;
        tokenChain: BigNumber;
        tokenType: number;
        decimals: number;
        symbol: string;
        name: string;
        wrappedTokenAddress: string;
      }
    >;
  };

  filters: {
    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "TokensBridged(bytes32,uint8)"(
      transferID?: BytesLike | null,
      tokenType?: BigNumberish | null
    ): TokensBridgedEventFilter;
    TokensBridged(
      transferID?: BytesLike | null,
      tokenType?: BigNumberish | null
    ): TokensBridgedEventFilter;

    "TokensBridgedBack(uint256,address,bytes32,bool)"(
      amount?: BigNumberish | null,
      to?: string | null,
      attestationID?: BytesLike | null,
      convertToNative?: null
    ): TokensBridgedBackEventFilter;
    TokensBridgedBack(
      amount?: BigNumberish | null,
      to?: string | null,
      attestationID?: BytesLike | null,
      convertToNative?: null
    ): TokensBridgedBackEventFilter;

    "TokensReleased(uint256,address,address,bool)"(
      amount?: BigNumberish | null,
      to?: string | null,
      token?: string | null,
      convertToNative?: null
    ): TokensReleasedEventFilter;
    TokensReleased(
      amount?: BigNumberish | null,
      to?: string | null,
      token?: string | null,
      convertToNative?: null
    ): TokensReleasedEventFilter;

    "WrappedTokensReleased(uint256,address,bytes32)"(
      amount?: BigNumberish | null,
      to?: string | null,
      attestationID?: BytesLike | null
    ): WrappedTokensReleasedEventFilter;
    WrappedTokensReleased(
      amount?: BigNumberish | null,
      to?: string | null,
      attestationID?: BytesLike | null
    ): WrappedTokensReleasedEventFilter;
  };

  estimateGas: {
    addDeployedToken(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    attestToken(
      _attestation: ITokenFactory.TokenAttestationStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    attestedTokens(
      attestationID: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bridgeTokens(
      _token: string,
      _amount: BigNumberish,
      _dstChain: BigNumberish,
      _dstAddress: string,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    bridgeTokensBack(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      _convertToNative: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    changeRelayer(
      _relayer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getDeployedToken(
      _wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSupportedTokens(overrides?: CallOverrides): Promise<BigNumber>;

    getWrappedToken(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isWrappedTokenSupported(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    relayer(overrides?: CallOverrides): Promise<BigNumber>;

    releaseTokens(
      _amount: BigNumberish,
      _to: string,
      _token: string,
      _convertToNative: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    releaseWrappedTokens(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    tokenFactory(overrides?: CallOverrides): Promise<BigNumber>;

    tokenTransfers(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    wrappedAttestedTokens(
      wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addDeployedToken(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    attestToken(
      _attestation: ITokenFactory.TokenAttestationStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    attestedTokens(
      attestationID: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bridgeTokens(
      _token: string,
      _amount: BigNumberish,
      _dstChain: BigNumberish,
      _dstAddress: string,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    bridgeTokensBack(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      _convertToNative: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    changeRelayer(
      _relayer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getDeployedToken(
      _wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSupportedTokens(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getWrappedToken(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isWrappedTokenSupported(
      _tokenAddress: string,
      _tokenChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    relayer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    releaseTokens(
      _amount: BigNumberish,
      _to: string,
      _token: string,
      _convertToNative: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    releaseWrappedTokens(
      _amount: BigNumberish,
      _to: string,
      _attestationID: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    tokenFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenTransfers(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    wrappedAttestedTokens(
      wrappedToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
